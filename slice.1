.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH SLICE 1 "EN Tools" "5/Feb/97" "EN Tools"
.IX Title "SLICE 1"
.UC
.IX Name "Slice - Extract pre-defined slices from an ASCII file"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
Slice -- Extract pre-defined slices from an ASCII file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\fBslice\fR
[\fB\-v\fR]
[\fB\-o\fR \fIsliceterm\fR:\fIoutputfile\fR[@\fIchmodcmd\fR] ..]
[\fIinputfile\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Input Principle"
.IX Subsection "Input Principle"
The \fIslice\fR program reads \fIinputfile\fR (or from \f(CWstdin\fR if \fIinputfile\fR is
not given or equal \*(L"\-") and divides its prepaired \s-1ASCII\s0 contents into possibly
overlapping areas, called slices.   These slices are determined by enclosing
blocks defined by begin and end delimiters which have to be already in the
file. These block delimiters use the syntax
.PP
.Vb 1
\&  [NAME: ... :NAME]
.Ve
or alternatively (if there is no mis-interpretation, i.e. no overlapping or
stacked slices)
.PP
.Vb 1
\&  [NAME: ... :]
.Ve
There can be as many such slice definitions as you like and there can be more
than one slice with the same name. The resulting slice is the union of all
equal named slices. Actually use this to spread a big slice over disjunct
peaces of the file.
.Sh "Output Selection Scheme"
.IX Subsection "Output Selection Scheme"
The final output data gets calculated by a slice term consisting of slice
names and set theory operators. The following syntax is recognized (in order
of grammar parsing) for slice terms:
.Ip "\s-1SLICE_TERM\s0 ::= \f(CW!NAME\fR | \f(CW~NAME\fR" 5
.IX Item "\s-1SLICE_TERM\s0 ::= \f(CW!NAME\fR | \f(CW~NAME\fR"
The complement of slice \s-1NAME\s0 (i.e. \s-1ALL\s0\eNAME).
.Ip "\s-1SLICE_TERM\s0 ::= \f(CWNAME1nNAME2\fR | \f(CWNAME1*NAME2\fR" 5
.IX Item "\s-1SLICE_TERM\s0 ::= \f(CWNAME1nNAME2\fR | \f(CWNAME1*NAME2\fR"
The intersection of slice \s-1NAME1\s0 and slice \s-1NAME2\s0.
.Ip "\s-1SLICE_TERM\s0 ::= \f(CWNAME1xNAME2\fR, \f(CWNAME1^NAME2\fR" 5
.IX Item "\s-1SLICE_TERM\s0 ::= \f(CWNAME1xNAME2\fR, \f(CWNAME1^NAME2\fR"
The exclusive or relation between slice \s-1NAME1\s0 and slice \s-1NAME2\s0.
.Ip "\s-1SLICE_TERM\s0 ::= \f(CWNAME1uNAME2\fR, \f(CWNAME1+NAME2\fR" 5
.IX Item "\s-1SLICE_TERM\s0 ::= \f(CWNAME1uNAME2\fR, \f(CWNAME1+NAME2\fR"
The union of slice \s-1NAME1\s0 and slice \s-1NAME2\s0.
.Ip "\s-1SLICE_TERM\s0 ::= \f(CWNAME1\eNAME2\fR, \f(CWNAME1-NAME2\fR" 5
.IX Item "\s-1SLICE_TERM\s0 ::= \f(CWNAME1\eNAME2\fR, \f(CWNAME1-NAME2\fR"
The difference of slice \s-1NAME1\s0 minus slice \s-1NAME2\s0.
.Ip "\s-1SLICE_TERM\s0 ::= \f(CW(\fR \s-1SLICE_TERM\s0 \f(CW)\fR" 5
.IX Item "\s-1SLICE_TERM\s0 ::= \f(CW(\fR \s-1SLICE_TERM\s0 \f(CW)\fR"
A grouped slice term. Use this to force a different order of evaluation.
.Sh "Advanced Selection: Slice Levels"
.IX Subsection "Advanced Selection: Slice Levels"
Because slices can be overlapping or stacked, a definition level is assigned
to each slice while the input is parsed. These levels range from 1 to the
maximum encounted (the level 0 is the whole file).  When a slice begins it is
assigned the lowest free level, beginning with level 1. As long as one level
is in use, it cannot be assigned again until the end delimiter of the
corresponding slice is seen. 
.PP
An example:
.PP
.Vb 1
\&     [A:[B::B]:A][C:[D:[E::C]:D][F::E]:F]
.Ve
.Vb 4
\&  3                     E-----------E
\&  2      B--B        D--------D 
\&  1   A--------A  C--------C     F-----F
\&  0 
.Ve
Here slice A is assigned level 1. Then B is assigned level 2 because level 1
is still in use by A. Then the end of B is reached, level 2 is freed.  Then
the end of A is reached and level 1 is also free now, so C is assigned level 1
again. Now only level 1 is in use, so D is assigned level 2. Then E is
assigned level 3. Then the end of C is seen and level 1 freed. Then the end of
D is seen and level 2 is freed. Now F begins and because only level 3 is in
use, it gets level 1 assigned. Then the end of E frees level 3 and the end of
F frees level 1. Finally no levels are still in use. This indicates that the
slicing is correct. If there are any used levels left at the end of this
processing this indicates an input error and \fIslice\fR will respond with an
error message.
.PP
This complicated level mechanism is needed for granular set operations where
particular slices should be included or excluded only. To make life easier, a
few pseudo-slices are automatically defined:
.Ip "\f(CWDEFn\fR" 5
.IX Item "\f(CWDEFn\fR"
The union of all user-defined slices at exactly level n (0 <= n <= maxlevel).
.Ip "\f(CWUNDEFn\fR" 5
.IX Item "\f(CWUNDEFn\fR"
The union of all not user-defined slices at exactly level n (0 <= n <=
maxlevel).  Actually this is just \f(CW!DEFn\fR.
.Ip "\f(CWDEF\fR" 5
.IX Item "\f(CWDEF\fR"
The union of all user-defined slices at \fBall\fR levels, beginning at 1.
Actually this is the union of all \f(CWDEFn\fR slices.
.Ip "\f(CWUNDEF\fR" 5
.IX Item "\f(CWUNDEF\fR"
The union of all non-user-defined slices at all levels, beginning with 1.
Actually this is just \f(CW!DEF\fR.
.Ip "\f(CWALL\fR" 5
.IX Item "\f(CWALL\fR"
The whole file. This actually is just \f(CWUNDEF0\fR, because at level 0 there are
no user defined slices, so all is undefined.
.SH "OPTIONS"
.IX Header "OPTIONS"
.Ip "[\fB\-o\fR \fIsliceterm\fR:\fIoutputfile\fR[@\fIchmodcmd\fR] ..]" 5
.IX Item "[\fB\-o\fR \fIsliceterm\fR:\fIoutputfile\fR[@\fIchmodcmd\fR] ..]"
This redirects the output to a file. Usually the whole file will be send to
\f(CWstdout\fR (same as \f(CWALL:-\fR). You can use this option \fImore than once\fR to
output to more than one file while the corresponding \fIsliceterm\fR determines
which output data will be included into each output file. 
.Sp
The optional \fIchmodcmd\fR string is intended for specifying options for the
\f(CWchmod\fR command, which is applied to \fIoutputfile\fR after writing. For
instance use ``\f(CWu+x\fR'\*(R' to create a file with the execution bit set (usually
used for \s-1SSI\s0 files on a webserver with the XBitHack option available).
.Ip "\fB\-v\fR" 5
.IX Item "\fB\-v\fR"
This sets verbose mode where some processing information will be given on the
console for debugging purpose.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Assume the following simple multi-language article file \fIarticle.src\fR,
written in HTML:
.PP
.Vb 5
\&  <html>
\&  <head>
\&  <title>[EN:Titlepage:][DE:Titelseite:]</title>
\&  </head>
\&  <body>
.Ve
.Vb 3
\&  <center>
\&  <h1>[EN:The Title itself:][DE:Der Titel selbst:]</h1>
\&  </center>
.Ve
.Vb 4
\&  <blockquote>
\&  [EN:...English Abstract...:]
\&  [DE:...Deutsche Zusammenfassung...:]
\&  </blockquote>
.Ve
.Vb 2
\&  [EN:...English Text...:]
\&  [DE:...Deutscher Text...:]
.Ve
.Vb 2
\&  </body>
\&  </html>
.Ve
Then the command 
.PP
.Vb 1
\&  slice -o ENuUNDEF:article.html.en -o DEuUNDEF:article.html.de
.Ve
creates the following to files:
.Ip "\fIarticle.html.en\fR:" 5
.IX Item "\fIarticle.html.en\fR:"
.Sp
.Vb 5
\&  <html>
\&  <head>
\&  <title>Titlepage</title>
\&  </head>
\&  <body>
.Ve
.Vb 3
\&  <center>
\&  <h1>The Title itself</h1>
\&  </center>
.Ve
.Vb 3
\&  <blockquote>
\&  ...English Abstract...
\&  </blockquote>
.Ve
.Vb 3
\&  ...English Text...
\&  </body>
\&  </html>
.Ve
.Ip "\fIarticle.html.de\fR:" 5
.IX Item "\fIarticle.html.de\fR:"
.Sp
.Vb 5
\&  <html>
\&  <head>
\&  <title>Titelseite</title>
\&  </head>
\&  <body>
.Ve
.Vb 3
\&  <center>
\&  <h1>Der Titel selbst</h1>
\&  </center>
.Ve
.Vb 3
\&  <blockquote>
\&  ...Deutsche Zusammenfassung...
\&  </blockquote>
.Ve
.Vb 3
\&  ...Deutscher Text...
\&  </body>
\&  </html>
.Ve
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
The program is implemented in the Perl 5 interpreter language and not in C, so
it is not as fast as it could be under runtime.  But usually its feature is
not needed under any fast runtime situation.  Usually \fIslice\fR is used for
offline generation of data files. Actually it was developed to generate
various HTML files from one source file.
.SH "AUTHOR"
.IX Header "AUTHOR"
.PP
.Vb 3
\&  Ralf S. Engelschall
\&  rse@engelschall.com
\&  www.engelschall.com
.Ve

.rn }` ''
